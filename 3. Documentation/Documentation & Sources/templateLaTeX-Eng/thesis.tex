%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% File: thesis.tex, version 1.9, May 2016
%%%
%%% =============================================
%%% This file contains a template that can be used with the package
%%% cs.sty and LaTeX2e to produce a thesis that meets the requirements
%%% of the Computer Science Department from the Technical University of Cluj-Napoca
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt,a4paper,twoside]{report}         
\usepackage{cs}              
\usepackage{times}
\usepackage{graphicx}
\usepackage{latexsym}
\usepackage{amsmath,amsbsy}
\usepackage{amssymb}
\usepackage[matrix,arrow]{xy}
\usepackage[T1]{fontenc}
\usepackage{ae,aecompl}
%\usepackage{shortcut} %definitii pentru diacritice; 
\usepackage{amstext}
\usepackage{graphics}
\usepackage[T1]{fontenc}
\usepackage{ae,aecompl}
\usepackage{algorithm}
%\usepackage{algorithmic}
\usepackage{color}
\usepackage{color}
\usepackage[super]{nth}
% \mastersthesis
\diplomathesis
% \leftchapter
\centerchapter
% \rightchapter
\singlespace
% \oneandhalfspace
% \doublespace

\renewcommand{\thesisauthor}{Mihai PÎȚU}    %% Your name.
\renewcommand{\thesismonth}{September}     %% Your month of graduation.
\renewcommand{\thesisyear}{2019}      %% Your year of graduation.
\renewcommand{\thesistitle}{SueC - An Editor and Interpreter for Pseudocode} 
\renewcommand{\thesissupervisor}{dr. eng. Emil Ștefan CHIFU}
\newcommand{\department}{\bf FACULTY OF AUTOMATION AND COMPUTER SCIENCE\\
COMPUTER SCIENCE DEPARTMENT}
\newcommand{\thesis}{LUCRARE DE LICEN'T'A}
\newcommand{\utcnlogo}{\includegraphics[width=15cm]{img/tucn.jpg}}

\newcommand{\uline}[1]{\rule[0pt]{#1}{0.4pt}}
%\renewcommand{\thesisdedication}{P\u{a}rin\c{t}ilor mei}

\begin{document}
%\frontmatter
%\pagestyle{headings}

\newenvironment{definition}[1][Defini\c{t}ie.]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}



%\thesistitle                    %% Generate the title page.
%\authordeclarationpage                %% Generate the declaration page.

\pagenumbering{arabic}
\setcounter{page}{4}



\begin{center}
\utcnlogo

\department

\vspace{4cm}

{\bf \thesistitle} %LICENSE THESIS TITLE}

\vspace{1.5cm}

LICENSE THESIS

\vspace{6cm}

Graduate: {\bf \thesisauthor} 

Supervisor: {\bf \thesissupervisor}

\vspace{3cm}
{\bf \thesisyear}
\end{center}

\thispagestyle{empty}
\newpage

\begin{center}
\utcnlogo

\department

\end{center}
\vspace{0.5cm}

%\begin{small}
\begin{tabular}{p{7cm}p{8cm}}
 %\hspace{-1cm}& APPROVED,\\
 \hspace{-1cm}DEAN, & HEAD OF DEPARTMENT,\\
 \hspace{-1cm}{\bf Prof. dr. eng. Liviu MICLEA} & {\bf Prof. dr. eng. Rodica POTOLEA}\\  
\end{tabular}
 
\vspace{2cm}

\begin{center}
Graduate: {\bf \thesisauthor}

\vspace{1cm}

{\bf \thesistitle}
\end{center}

\vspace{1cm}

\begin{enumerate}
 \item {\bf Project proposal:} {\it Short description of the license thesis and initial data}
\item {\bf Project contents:} {\it (enumerate the main component parts) Presentation page, advisor's evaluation, title of chapter 1, title of chapter 2, ..., title of chapter n, bibliography, appendices.}
\item {\bf Place of documentation:} {\it Example}: Technical University of Cluj-Napoca, Computer Science Department
\item {\bf Consultants:}
\item {\bf Date of issue of the proposal:} November 1, 2017
\item {\bf Date of  delivery:} February 18, 2019 {\it (the date when the document is submitted)}
  \end{enumerate}
\vspace{1.2cm}

\hspace{6cm} Graduate: \uline{6cm} 

\vspace{0.5cm}
\hspace{6cm} Supervisor: \uline{6cm} 
%\end{small}

\thispagestyle{empty}


\newpage
$ $
%\begin{center}
%\utcnlogo

%\department
%\end{center}

\thispagestyle{empty}
\newpage

\begin{center}
\utcnlogo

\department
\end{center}

\vspace{0.5cm}

\begin{center}
{\bf
Declara\c{t}ie pe proprie r\u{a}spundere privind\\ 
autenticitatea lucr\u{a}rii de licen\c{t}\u{a}}
\end{center}
\vspace{1cm}



Subsemnatul(a) \\
\uline{14.8cm}, 
legitimat(\u{a}) cu \uline{4cm} seria \uline{3cm} nr. \uline{4cm}\\
CNP \uline{9cm}, autorul lucr\u{a}rii \uline{2.8cm}\\
\uline{16cm}\\
\uline{16cm}\\
elaborat\u{a} \^{\i}n vederea sus\c{t}inerii examenului de finalizare a studiilor de licen\c{t}\u{a} la Facultatea de Automatic\u{a} \c{s}i Calculatoare, Specializarea \uline{7cm} din cadrul Universit\u{a}\c{t}ii Tehnice din Cluj-Napoca, sesiunea \uline{4cm} a anului universitar \uline{3cm}, declar pe proprie r\u{a}spundere, c\u{a} aceast\u{a} lucrare este rezultatul propriei activit\u{a}\c{t}i intelectuale, pe baza cercet\u{a}rilor mele \c{s}i pe baza informa\c{t}iilor ob\c{t}inute din surse care au fost citate, \^{\i}n textul lucr\u{a}rii \c{s}i \^{\i}n bibliografie.

Declar, c\u{a} aceast\u{a} lucrare nu con\c{t}ine por\c{t}iuni plagiate, iar sursele bibliografice au fost folosite cu 
respectarea legisla\c{t}iei rom\^{a}ne \c{s}i a conven\c{t}iilor interna\c{t}ionale privind drepturile de autor.

Declar, de asemenea, c\u{a} aceast\u{a} lucrare nu a mai fost prezentat\u{a} \^{\i}n fa\c{t}a unei alte comisii de examen de licen\c{t}\u{a}.

\^{I}n cazul constat\u{a}rii ulterioare a unor declara\c{t}ii false, voi suporta sanc\c{t}iunile administrative, respectiv, \emph{anularea examenului de licen\c{t}\u{a}}.

\vspace{1.5cm}

Data \hspace{8cm} Nume, Prenume

\vspace{0.5cm}

\uline{3cm} \hspace{5cm} \uline{5cm}

\vspace{0.5cm}
\hspace{9.4cm}Semn\u{a}tura

\thispagestyle{empty}

\newpage


%\listoftables
%\listoffigures

%\clearpage 
%\newpage

%\begin{comment}
\include{guideline} 
%\end{comment}

\newpage

\tableofcontents
\newpage

\chapter{Introduction - Project Context}
\pagestyle{headings}
\section{Project Context}

	Computer science and programming is taught in schools around Romania for at least 30 years, especially in high schools, but also in secondary schools, starting with the \nth{5} grade. Before introducing directly to a programming language, many teachers use a pseudocode language which serves as a mean of understanding programming concepts in a more universal manner, bringing it closer to the natural spoken language. I have decided to make an implementation of this pseudocode by creating an editor and interpreter for it.
	
	The purpose of this project is to create an easier way of learning programming concepts for students who are new into this domain. This will serve as a fresh renewal of software used in schools today, as older tools such as Code::Blocks and/or Free Pascal are still used in schools and programming contests.
 
	SueC is the name of the editor which creates, edits and compiles files which represent pseudocode files. This editor will work also like any other editors, providing some error-checking mechanisms and returning the result after compiling a pseudocode file.
	
\section{Motivation}
	During high school, many of my colleagues have struggled learning programming and computer science as they had issues in understanding the simple paradigms because of C programming language. They have improved throughout the high school due to the teacher using pseudocode as a mean of explaining simple algorithms and paradigms, but there were some struggle shown for some when changing the pseudocode into implementations in C. 
	
	Nowadays, this issue is still persistent in schools in Romania as C and Pascal are used as main programming languages for teaching, exams and computer science contests. There are some more interactive programming languages such as Scratch which uses a graphical interface for implementing simple programs, but since the target audience is for primary school students, there is a need for an attractive way of making secondary and high school students for understanding programming at their age group. 
	
	At the moment, there are platforms for learning code such as CodeCademy and Udemy which contain basic courses for people at every age, but the main focus is for people who have a little background in programming and computer science.
	
	

\chapter{Project Objectives and Specifications}


As the title of the project suggests - "An Editor and Interpreter for Pseudocode" - this is an application which will serve as an educational tool for using the pseudocode as a programming language.

For the users of this application(students and/or teachers), the main functionalities of this application are:
\begin{itemize}
	\item Creating/opened a file in which pseudocode can be implemented.
	\item Writing pseudocode in the file created/opened.
	\item Compiling the file and obtaining the desired result or error(s) if there are occured.
	\item Running some step-by-step basic tutorials which are aimed for learning the language.
\end{itemize}


The main objectives of this project are:
\begin{itemize}
	\item Developing an user-friendly application which handles the main file handling operations and communicating with the compiler of the pseudocode source files.
	\item Creating an understandable programming language that resembles the pseudocode used by teachers in schools and/or universities. For a technical point of view, the pseudocode will be created like any other programming languages, having similar elements to existing ones that are used nowadays, but also with specific structural elements bringing it closer to the natural language.
	\item Developing a compiler for this programming language by defining a lexical and syntactic analyzer respectively. These analyzers contain the set of rules that apply to the programming language. 
\end{itemize}





\chapter{Bibliographic research}

For this project, my research done was focused on the main components and technologies included in the project:
\begin{enumerate}\bfseries
	\item C Programming Language
	\item Python Programming Language
	\item Lex
	\item Yacc
\end{enumerate}
 
\section{C Programming Language}
 C is a general-purpose, procedural computer programming language supporting structured programming, lexical variable scope, and recursion, while a static type system prevents unintended operations. This programming language was created between 1972 and 1973 as a way of making utilities work in Unix operating system, later being used for reimplementing the kernel of this OS. Since 1980s, C has gained enough popularity becoming one of the most widely used programming languages in the world. During this time, there were several C compilers created by several vendors for being available for the majority of existing computer architectures and operating systems. Since 1989, C has been standardized by ANSI (American National Standards Institute) and by the International Organization for Standardization (ISO). 
  
 Being an imperative procedural language, C was designed to be compiled using a relatively straightforward compiler to provide low-level access to memory and language constructs that map efficiently to machine code instructios all with minimal runtime support. This language supports cross-platform programming, making it available in numerous platforms, from embedded microcontrollers and supercomputers. It also stood as a big influence in the creation of other programming languages, such as:
 \begin{itemize}
 	\item C++
 	\item C\#
 	\item Java
 	\item Python
 	\item Go
 \end{itemize}

 The C programming language syntax is defined by a formal grammar, having specific keywords and rules based on statements to specify different actions. The most common statement is an expression statement, consisting of an expression to be evaluated followed by a semicolon. The main structure of a C program consists of declarations and function definitions, which in turn contain declarations and statements. 
 
 Besides exxpressions, the main sequence execution of statements can contain several control-flow statements defined by reserved keywords:
  
 \begin{itemize}
 	\item Conditional execution 
 	
 		This is defined by \textit{if} and \textit{else} statements. These statements contain an expression that the \textit{if} checks if it is true or not and execute statements based on a condition.
 		
 		Alongside those statements, there exists the \textit{switch} statement in which it displays a \textit{case} based on the expression given.
 		
 	\item Iterative execution (Looping)
 	
 		This is defined by \textit{while} , \textit{do-while} and \textit{for} statements which can loop through a certain set. The \textit{for} statement contains separate expressions for initialization, testing and reinitialization, any of which can be omitted. 
 \end{itemize}


\section{Python Programming Language}

Python is an interpreted, high-level, general-purpose programming language with the aim to help programmers with clear, logical code for small and large-scale projects. It was conceived in the late 1980s as a successor to ABC language, but it was released in 1991. Python is dynamically typed and garbage-collected, supporting multiple programming paradigms, such as: procedural, object-oriented and functional. Due to this and its comprehensive standard library, Python is often described as a "batteries included" language. 

Due to supporting multiple programming paradigms, Python is used in a lot of domains. Object-oriented programming and structured programming are fully supported, but it also includes features from functional programming and aspect-oriented programming. Other paradigms can be supported by Python via extensions, including even logic programming and design by contract. 

Python is meant to be an easily readable language due to its syntax and semantics. The format is visually uncluttered, using English keywords more often than punctuation. Curly brackets are not used to delimit blocks and semicolons are optional. For block delimitation, whitespace indentation is used. A decrease in indentation shows that the current block of code is finished. With this method, it is shown that the program's visual structure accurately represents the program's semantic structure. 

\section{Technologies used}

\subsection{Lex}

Lex is a computer program designed for generating lexical analyzers. It is the standard lexical analyzer generator on many Unix systems, having an equivalent tool as part of the POSIX standard. It is commonly used with \textit{yacc} parser generator.

Lex reads an input stream specifying the lexical analyzer and outputs source code implementing a lexer in C. This input stream is given to Lex directly as standard input from the user or a file that contains the 

\subsection{Yacc}

Yacc\textit{(Yet Another Compiler-Compiler)} is a computer program for the Unix operating system. It is a LALR\textit{(Look Ahead Left-to-Right)} parser generator, which generates a parser, the part of a compiler that tries to make syntactic sense of the source code. 

\subsection{Java Programming Language}
Java is a general-purpose programming language that is object-oriented and class-based. It is designed to have as few implementation dependencies as possible, with the intention to letting application developers apply the WORA rule (Write Once, Run Anywhere) - all compiled Java code can run on all platforms that support Java without the need for recompilation. 
Java applications are typically compiled to bytecode that can be run on any Java Virtual Machine (JVM), regardless of the underlying computer and/or software architecture. 

This programming language has been designed in May 1995 by James Gosling from Sun Microsystems (now being acquired by Oracle) being licensed under the same companu. Since May 2007, Java has been relicensed under GNU General Public License with the original Java compilers, virtual machines and class libraries. Nowadays, this programming language is one of the most popular programming languages in use, mainly for client-server applications. 

The syntax of Java is similar to C and C++, but it has fewer low-level facilities than either of them. The main draw for the programming language is being class-based. Classes are a code template for creating objects, providing initial values for state (variables/attributes) and implementations of behavior (methods). Besides creating objects, a class can be used as a standalone program, running imperatively as any C or C++ program. The main goals in the creation of this language are:
\begin{itemize}
 \item The language must be simple, object-oriented and familiar.
 \item The language must be robust and secure.
 \item The language must be architecture-neutral and portable.
 \item The language must execute with high performance.
 \item The language must be interpreted, threaded and dynamic.
\end{itemize}


\subsection{Java Swing UI}

Java Swing is a GUI widget toolkit for Java, creating desktop applications similar to Windows Forms. It provides a more sophisticated set of GUI components than the earlier Abstract Window Toolkit (AWT), making it easir to emulate application functionalities with powerful and flexible components. 

This framework follows a single-threaded programming model, applying functionalities similar to Model-View-Controller design pattern. Each Swing component has an associated model specified in terms of a Java interface that can be used either as the default implementation or as a variation of the component created by the developer. Based on this model and the MVC pattern, it offers loose coupling between components and elements of the application.


\chapter{Analysis and Theoretical Foundation}
\section{Editor Application}
\subsection{Model-View-Controller(MVC) Architecture}

Model-View-Controller (MVC) is a software design pattern commonly used for developing user interfaces which divides the related program logic into three interconnected elements. It is used mainly for designing the layout of a page (Desktop or Web). Although it has been traditionally used for desktop applications, this pattern has become popular in designing web applications. There are specified MVC frameworks for web and mobile application development in popular programming languages like: Java, C\#, Swift, Python, Ruby, JavaScript and PHP.


The main components of this design pattern are:

\begin{itemize}
\item \textbf{Model}
		
It represents the central component of the pattern, being the application's dynamic data structure, independent of the user interface. It directly manages the data, logic and rules of the application.

\item \textbf{View}

It represents the visual element of the pattern, being any representation of information possible, like: charts, tables, diagrams, pages, forms etc. 

\item \textbf{Controller}

Accepts input from the view and converts the data obtained into commands that are directed to the model and/or view.
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[scale=0.2]{img/MVCDiag.png}
	\caption{Model-View-Controller Diagram}
\end{figure}

Besides the division of the application into these components, this pattern defines the interactions between the components:

\begin{itemize}
	\item The model of the application is responsible for managing the data of the application. The user input is received from the controller.
	\item The view represents a presentation of the model having a particular format.
	\item The controller responds to the user input given in the view(s) and performs interactions on the data model objects.
\end{itemize}

Model-View-Controller pattern offers different advantages in regards to developing applications, such as:
\begin{itemize}
	\item \textbf{Simultaneous development over the code} 
	
	Multiple developers can work simultaneously on the model, controller and views, having no change in the actual structure of the system.
	\item \textbf{High cohesion}
			
	The cohesion is defined in computer programming as the degree to which the elements inside a module belong together. In other terms, it acts as a measure of the strength of relationship between the methods and data of one class and some unifying purpose or concept served by the class.
	
	In object-oriented programming, the term "cohesion" is used quite frequently together with coupling. The methods that serve in a class tend to be similar in many aspects, then that class is said to have high cohesion. A highly cohesive system has a manageable complexity, due to the increase of code readability and reusability. 
	
	This pattern presents this characteristic by having logical groupings of related actions in one controller altogether. Also, multiple views that are associated to a model can be grouped together. 
	
	\item \textbf{Loose coupling}
	
	Besides the cohesion, which serves the degree of "togetherness" of elements inside a module, the coupling is described as the degree of independence between software modules i.e. the strength of the relationships between modules between a system.
	
	A loosely coupled system is one which each of its components makes use of little or no knowledge of the definitions of other separated components. The main subareas include the coupling of classes, interfaces, data and services. Loose coupling goes hand-in-hand with high cohesion by having an manageable complexity and the ease of use of alternative implementations that provide the same services. 
	
	In the case of Model-View-Controller pattern, its nature and workflow shows the existence of a loose coupling between the Model, View and Controller of the application.	

\end{itemize} 

	
\section{Interpreter}

An interpreter is a computer program that directly executes instructions written in a programming or scripting language, without requiring them to have been compiled into a machine code language program. For program execution, an interpreter uses one of these strategies:

\begin{itemize}
	\item Parsing the source code and performing its behavior directly;
	\item Translating the source code into efficient intermediate representation and immediately execute this;
	\item Explicitly execute stored precompiled code made by a compiler which is part of the interpreter system.
\end{itemize}

Historically speaking, interpreters have been used since 1952 to ease programming within the limitations of computers existing at that time. Another usage of them was to translate between low-level machine languages, allowing code to be written for machines that were still under development and tested on computers that already existed. The first interpreted high-level language was Lisp. Nowadays, programs written in a high-level language are either directly executed by some kind of interpreter or converted into machine code by a compiler for the CPU to execute.

There are some differences between a compiler and interpreter, mainly in the functionality. A compiler works most of the time with an assembler and linker. It produces machine code most of the time to be executed by the computer hardware, but it can often produce object code, an intermediate form. An object code is the same machine code created before, but with the addition of a symbol table containing names and tags to make executable blocks (or modules) identifiable and relocatable. The linker comes into working by combining these object file(s) with libraries that are included in the compiler in order to create a single executable file. On the other hand, a interpreter written in a low-level language may have similar machine code blocks implementing functions of the high level language stored and executed when a function's entry in a look up table points to that code. However, an interpreter written in a high level language uses another approach, such as: generating and walking a parse tree, generating and executing intermediate software-defined instructions or both approaches.

Both compilers and interpreters generally turn source code into tokens, generate a parse tree. The basic difference is that a compiler system (along with a linker) generates a stand-alone machine code program, whereas an interpreter system performs the actions described by the high level program.

For this project, this interpreter is written in C, a high level language, being split into three parts:
\subsection{Lexical Analyzer}
	
	Lexical analysis (or tokenization) is the process of converting a sequence of characters into a sequence of tokens. A program that performs lexical analysis is called a lexer or tokenizer.
	
	In modern processing, a lexer forms the first phase of a compiler frontend, occuring mostly in one pass of the source code. A lexer is used alongside with a parser in most compilers and interpreters. It splits the source code, sentence by sentence, into tokens. Tokens are strings with an assigned meaning, being structured as a pair consisting of a token name and an optional token value. The token names can generally be split into:
	
	\begin{itemize}
		\item \textit{Identifiers} - Names that a programmer/developer chooses.
		\item \textit{Keywords} - Names that are already defined in the programming language
		\item \textit{Separators/Punctuators} - Punctuation characters and paired-delimiters
		\item \textit{Operators} - Symbols that operate on arguments and produce results
		\item \textit{Literals} - Numeric, logical, textual, reference literals
		\item \textit{Comments} - Line, block comments 
	\end{itemize}
	
	When a statement is given as a source, the lexer splits every element of the statement, creating one token per element. For example, we consider a C expression: 
	
	\textit{c = a * (b + 5);}
	
	The lexer gets this statement, passes through its all defined lexems (the source program that matches the pattern for a token) and creates the token based on their lexem appartenance. In this case, the statement is split into tokens that are categorised:
	\begin{table}[H]
	\centering
\begin{tabular}{|c|c|c|c|l}
\cline{1-4}
\multicolumn{1}{|l|}{identifier} & \multicolumn{1}{l|}{operator} & \multicolumn{1}{l|}{separator} & \multicolumn{1}{l|}{literal} &  \\ \cline{1-4}
c                                & =                             & (                              & 5                            &  \\ \cline{1-4}
a                                & *                             & )                              &                              &  \\ \cline{1-4}
b                                & +                             & ;                              &                              &  \\ \cline{1-4}
\end{tabular}
\end{table}

	The tokens obtained are, then, passed to the parser.
	
\subsection{Syntactic Analyzer}
	Syntactic analysis (or parsing) is the process of analyzing a string of symbols, either in natural language, computer languages or data structures, conforming to the rules of a formal grammar. In computer science, a parser is a software component that takes input data and builds a data structure - often a parse tree, abstract syntax tree or other hierarchical structure, giving a structural representation of the input while checking for correct syntax. In most cases, a lexer works hand-in-hand with a parser.
	
	After obtaining the tokens from the lexer, each token is analyzed based on its token name and creates a parse tree which is needed for passing through in order to get an order of operation handling, giving the response. 
	%\ Aci bag exemplul cu diagrama pe care o folosesc si la parse tree si explic de frunze ca-s identificatori/literali
\subsection{Parse Tree}
 	
 	The parse tree is the result of parsing the tokens from the lexer. Passing the tree determines the order of the operations done, giving the results. There are two ways of performing the pass of the tree:
 	
 	\begin{itemize}
 		\item \textbf{Top-down parsing}
 		
 		This method can be viewed as an attempt to find the left-most derivations of an input stream by searching for parse trees using a top-down expansion of the given formal grammar rules. Tokens are consumed from left to right.
 		
 		\item \textbf{Bottom-up parsing}
 		
 		A parser can start with the input and attempt to rewrite it to the start symbol. In this case, the input is represented by the leaves of the parse tree, being the most basic elements. The best example of this case are the LR(Left-to-right Rightmost) parsers, which analyze deterministic context-free languages in linear time.
 	\end{itemize}

\chapter{Detailed Design and Implementation}

\section{Project Component Diagram}
\begin{figure}[h]
 \centering
 \includegraphics[scale=0.6]{img/CompDiag.png}
 \caption{Component Diagram}
\end{figure}

This project is split into two main components:
\begin{itemize}
	\item Editor Application
	\item SueC Interpreter
\end{itemize}

These components communicate bidirectionally in order to ensure a good workflow:
\begin{itemize}
	\item The editor application runs the interpreter that compiles the source file via running the Linux process.
	\item The result from the interpretation is then written in a file that is read by the editor application and displayed it there.  
\end{itemize}


\section{Editor Application}
The editor application is a Java Swing Desktop application that acts as the main interface of compiling SueC code files. The main purpose of creating it was to have a simple and easy-to-read graphical user interface for an user to create, edit and run SueC code files.
\subsection{Packages}

The main structure of the application (see Figure 5.2) is based on the Model-View-Controller pattern:
\begin{itemize}
 \item The \textit{Model} component is represented by the main models used in the project.
 \item The \textit{View} component is represented by the Swing views created to display specific tasks.
 \item The \textit{Controller} component is already integrated into the Java Swing architecture, as these are represented by the event handlers used for each component used in each view.
\end{itemize}

\begin{figure}[h]
 \centering
 \includegraphics[scale=0.5]{img/packagediag.png}
 \caption{Package Diagram}
\end{figure}

Besides the MVC-like packages, there are also packages used for other functionalities that are used to ensure the workflow of the Editor App and the SueC Interpreter.

\begin{enumerate}
 \item \textbf{\textit{models} package}
 
 \begin{figure}[h]
 \centering
 \includegraphics[scale=0.4]{img/ModelsPackage.png}
 \caption{Class diagram of \textit{models} package}
\end{figure}

This package contains the main models used in the project for representing the educational part of the application.  
\begin{itemize}
 \item \textbf{Tutorial} class
    
    This class resembles a simple version of a tutorial object. It is used for adding the tutorial data for the tutorial views. Each tutorial contains:
    \begin{itemize}
        \item \textit{id} - the number associated to the tutorial
        \item \textit{title} - the title of the tutorial
        \item \textit{description} - the description of the tutorial
        \item \textit{task} - the task required for the user to finish the tutorial
        \item \textit{answer} - the expected answer that the interpreter should give after the user runs the task.
    \end{itemize}
    
    \item \textbf{Guide} class
    
    This class resembles a simple version of a guide object. It is used for adding the guide data for the guide views. Each tutorial contains:
    \begin{itemize}
        \item \textit{id} - the number associated to the guide
        \item \textit{title} - the title of the guide
        \item \textit{description} - the description of the guide
        \item \textit{example} - am example of usage of the notion described in the guide
    \end{itemize}
\end{itemize}
These resource files are JSON files - \textit{tutorials.json} and \textit{guides.json} - that contain a list of tutorial and guide objects, respectively. The lists are then used for displaying the tutorials/guides in the application. The model classes are used as the template objects for these JSON resource files.

\item \textbf{\textit{views} package}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{img/ViewsPackage.png}
    \caption{Views Package}
    \label{fig:conf}
\end{figure}

This package contains all the view classes that are displayed in the application. These classes have been made using components from Java Swing that were directly used or extended in objects from the \textbf{\textit{commons}} package.

All views that are shown are created from extending the \textbf {BaseView} class. This class holds the main structure of the views, all other views being extended from this. Itself, it is extended from \textbf{JFrame} class that comes from Swing library - creating the actual frame that is displayed to the user. The view consists of:
\begin{itemize}
 \item \textbf{Main Menu Bar} - it is defined in the \textbf{\textit{commons}} package as a \textbf{MainMenuBar} object, an extension of the associated Swing object. It holds all of the menus that are also defined and used throughout the views. 
 \item \textbf{Help Menu} - one of the defined menus created  in \textbf{\textit{commons}} package and used in all the views. It is a \textbf{HelpMenu} object. 
 \item \textbf{Main Panel} - a JPanel object that serves as the main panel of the JFrame. Each view adds elements only to this element, as it is structured as a grid with one column and two or three columns, depending on the view.
\end{itemize}

The other views are created and grouped based on their functionality. These views are linked via events that are triggered by accessing the menu options from the menu bar.  

\begin{enumerate}
 \item \textbf{Main View - MainView} class
 
 This view is the first view that can be seen when running the application. It is used as a welcome screen at the start of the application. The main panel contains only two labels that display a welcome message to the app.
 
 \item \textbf{File View - FileView} class
 
 This view represents the editor where an user can edit and compile SueC source code. It can be accessed when creating or opening a SueC source code file. The main panel contains two text areas:
 \begin {itemize}
  \item \textbf{Code text area}
  
  This area is used by the user to write the source code. At the start of the view lifecycle, this text area is loaded with the contents of the source file. After that, the user can edit the contents of the source code using that text area and save it or compile the code.
  
 \item \textbf{Output text area}
 
 This area is used by the user to see the output after compiling the code written in the code area. This area is read-only and it can only be modified by the output of the compiler. 
 \end {itemize}

 The design of the view is quite simple as it holds a straightforward approach towards using the application. The user can write the code in the code text area, run the compiler by accessing the compile menu and pressing "Compile file...". Then, the output is shown in the output text area. 
 
 \item \textbf{Tutorial View - TutorialView}
 
 This view is the main menu view for the tutorials. It holds the structure of \textbf{BaseView}, but the main panel layout being a three-rows grid. The first two rows hold a welcome message for getting into the menu. The last row is split in two columns.
 \begin{itemize}
  \item The left column contains a button with label \textit{Start Tutorials}. When pressing the button, the user is redirected to the first tutorial of the tutorial list.
  \item The right column is a JList that contains the tutorials that are loaded at the start of the application life cycle. When pressing on one tutorial from the list, the user is redirected to that specified tutorial and starts the tutorials from that selected item. 
 \end{itemize}
 
 After running all the tutorials, the user is redirected back to this view.
 
 \item \textbf{Dynamic Tutorial View - DynamicTutorialView}
 
 This view represents the actual tutorial structure and has the tutorial elements implemented. Structurally, the main panel is 
 also split into three rows:
 \begin{itemize}
 \item \textbf{Top Panel}
 
 This panel serves as a command panel. It is split into three columns and contains:
 \begin{itemize}
    \item \textit{Back} button 
        
        It redirects the user to the previous tutorial. This button is not shown in the first tutorial.
    \item Title label 
        
        A label that contains the title of the tutorial.
    \item \textit{Next/Finish} button
    
        Excepting the last tutorial, the button displayed is a \textit{Next} button that, when clicked, the user is redirected to the next tutorial. 
        
        At the last tutorial, when finished, the \textit{Finish} button is shown. When the user presses this button, it receives a pop-up message containing the message "Congratulations! You finished all the tutorials!" and, after closing the message, the user is redirected to the \textbf{TutorialView}.
        
        The \textit{Next/Finish} button is not displayed at the start of the view life cycle, but it appears when the user finishes the task given successfully.  
 \end{itemize}
 
 \item \textbf{Description Panel}
 
 This panel is split into two columns. It contains the main information of a tutorial. The left column is represented by the description of a tutorial that holds its main purpose of a computer programming notion that can be represented in SueC programming language. The right column contains the task of the tutorial - the requirements to implement the notion in the description.
 
 \item \textbf{Code Panel}
 
 The code panel contains the components that the user interacts with for completing the tutorial. It is also split in two columns, having a simpler, smaller version of the \textbf{FileView} structure.
 
 The left column contains the code text area where the user performs the task given for the tutorial. The right column contains the output text area - a read-only text area that shows the result of running the tutorial. Besides this, the column also contains a button with the label \textit{Compile tutorial} that, when pressed, it compiles the code written in the code area. 
 \end{itemize}
 
 \item \textbf{Guide View - GuideView}
 
 This view is the main menu for the guides. The structure is similar to the structure of the \textbf{TutorialView} - a three-row grid:
 \begin{itemize}
  \item The first two grids contain a welcome message for getting into the guide menu.
  \item The third row is split in two columns. The left column contains a button with the label \textit{Start guides} that opens the guide list starting from the first element. The right column contains a JList with all the guides that are preloaded at the start of the application life cycle. When clicking one of the elements, the user is redirected to the selected guide view and starts the guide list from the selected item.
 \end{itemize}
 
 
 \item \textbf{Dynamic Guide View - DynamicGuideView}
 
 This view represents the actual guide structure, where all the guide elements are displayed. It has the same structure as \textbf{DynamicTutorialView}, being split into three rows:
 \begin{itemize}
  \item \textbf{Top Panel}
 
 This panel serves as a command panel. It is split into three columns and contains:
 \begin{itemize}
    \item \textit{Back} button 
        
        It redirects the user to the previous guide. This button is not shown in the first guide.
    \item Title label 
        
        A label that contains the title of the guide.
    \item \textit{Next/Finish} button
    
        Excepting the last guide, the button displayed is a \textit{Next} button that, when clicked, the user is redirected to the next guide. 
        
        At the last guide, when finished, the \textit{Finish} button is shown. When the user presses this button, it receives a pop-up message containing the message "Congratulations! You finished reading all the guides!" and, after closing the message, the user is redirected to the \textbf{GuideView}.
        
 \end{itemize}
 
 \item \textbf{Description Panel}
 
 This panel is split into two columns. It contains the main information of a tutorial. The left column is represented by the description of a guide that describes a computer programming notion that can be represented in SueC programming language. The right column contains an implementation example of the guide.
 
 \item \textbf{Code Panel}
 
 The code panel is an empty panel.  
 \end{itemize}


\end{enumerate}



\item \textbf{\textit{commons} package}

This package contains all the user-defined GUI elements that are displayed in the views. Besides the GUI objects, it also has the events triggered in the views. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{img/CommonsPackage.png}
    \caption{Commons Package}
    \label{fig:conf}
\end{figure}

The classes are defined in two packages: 
\begin{itemize}
 \item \textbf{logger} package 
 
 This package contains only one class - \textbf{LoggerConfig}. This class defines the logging system used throughout the application. It is defined as a wrapper over the \textbf{Logger} class from Java Util, redirecting all the logs into a file called and found in . The main operations wrapped are for logging information (\textit{infoLog}) and errors (\textit{errorLog}).
 
\end{itemize}


\end{enumerate}



\chapter{Testing and Validation}

About 5\% of the paper
\section{Title}
\section{Other title}

\chapter{User's manual}

In the installation description section your should detail the hardware and software resources needed for installing and running the application, and a step by step description of how your application can be deployed/installed. An administrator should be able to perform the installation/deployment based on your instructions.

In the user manual section you describe how to use the application from the point of view of a user with no inside technical information; this should be done with screen shots and a stepwize explanation of the interaction. Based on user's manual, a person should be able to use your product.

\section{Title}
\section{Other title}

\chapter{Conclusions}

About. 5\% of the whole

Here your write:
\begin{itemize}
\item a summary of your contributions/achievements,
\item a critical analysis of the achieved results,
\item a description of the possibilities of improving/further development.
\end{itemize}
\section{Title}
\section{Other title}


%\addcontentsline {toc}{chapter}{Bibliography} 
\bibliographystyle{IEEEtran} 
\bibliography{thesis}%same file name as for .bib

\include{apendix}

\end{document}
